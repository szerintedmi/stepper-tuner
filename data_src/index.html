<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Stepper Tuner</title>
    <link rel="stylesheet" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="icon" href="/favicon.ico" type="image/x-icon" />
  </head>
  <body>
    <header>
      <h1>Stepper Tuner</h1>
      <div id="updated">Waiting…</div>
    </header>

    <main class="cards">
      <section class="card full">
        <div class="card-header">
          <h2>Motors</h2>
          <button type="button" id="toggle-motor-editor" class="secondary compact">
            Edit motors
          </button>
        </div>
        <div id="run-hint" class="hint"></div>
        <div class="table-scroll">
          <table class="motors-table">
            <thead>
              <tr>
                <th>Motor</th>
                <th>Pos</th>
                <th>Target</th>
                <th class="limits-head hidden">Limits</th>
              </tr>
            </thead>
            <tbody id="motors-table-body">
              <tr class="empty">
                <td colspan="5">No motors configured. Use Edit motors to add one.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div id="motor-editor" class="motor-editor hidden">
          <h3>Motor Editor</h3>
          <div id="motor-edit-list" class="motor-edit-list"></div>

          <h4>Add Motor</h4>
          <div class="motor-add-grid">
            <label>
              Step pin
              <input id="motor-editor-step" type="number" min="0" step="1" />
            </label>
            <label>
              Dir pin
              <input id="motor-editor-dir" type="number" min="0" step="1" />
            </label>
            <label>
              Sleep pin
              <input id="motor-editor-sleep" type="number" min="0" step="1" />
            </label>
          </div>
          <div class="form-actions">
            <button type="button" id="motor-editor-add">Add motor</button>
          </div>
          <div id="motor-editor-hint" class="hint"></div>
        </div>
      </section>

      <section class="card">
        <h2>Motion Settings</h2>
        <form id="settings-form" class="form-grid">
          <label>
            Steps per rev
            <input id="steps-per-rev" type="number" min="1" step="1" required />
          </label>
          <label>
            Max speed (steps/s)
            <input id="max-speed" type="number" min="1" step="1" required />
          </label>
          <label>
            Acceleration (steps/s²)
            <input id="acceleration" type="number" min="1" step="1" required />
          </label>
          <label class="toggle">
            <input type="checkbox" id="limits-enabled" />
            <span>Enable motion limits</span>
          </label>
          <div id="limit-settings" class="limit-grid hidden">
            <label>
              Min position (steps)
              <input id="limit-min" type="number" step="1" />
            </label>
            <label>
              Max position (steps)
              <input id="limit-max" type="number" step="1" />
            </label>
          </div>
          <label class="toggle" id="auto-sleep-toggle">
            <input type="checkbox" id="auto-sleep" checked />
            <span>Auto sleep driver</span>
          </label>
        </form>
        <div class="form-actions motion-actions">
          <button type="button" id="save-defaults">Save defaults</button>
          <button type="button" class="secondary" id="reset-default">
            Reset to default
          </button>
        </div>
        <div id="form-hint" class="hint"></div>
      </section>
    </main>

    <script>
      const el = (id) => document.getElementById(id);

      const stepsInput = el("steps-per-rev");
      const maxSpeedInput = el("max-speed");
      const accelInput = el("acceleration");
      const limitsToggle = el("limits-enabled");
      const limitSettings = el("limit-settings");
      const limitMinInput = el("limit-min");
      const limitMaxInput = el("limit-max");
      limitMinInput.disabled = true;
      limitMaxInput.disabled = true;
      const autoSleepToggle = el("auto-sleep");
      const formHint = el("form-hint");
      const runHint = el("run-hint");
      const updatedEl = el("updated");
      const saveDefaultsButton = el("save-defaults");
      const resetDefaultsButton = el("reset-default");
      const toggleMotorEditorBtn = el("toggle-motor-editor");
      const motorEditor = el("motor-editor");
      const motorEditList = el("motor-edit-list");
      const motorEditorHint = el("motor-editor-hint");
      const motorEditorStep = el("motor-editor-step");
      const motorEditorDir = el("motor-editor-dir");
      const motorEditorSleep = el("motor-editor-sleep");
      const motorEditorAddBtn = el("motor-editor-add");
      const motorsTableBody = el("motors-table-body");
      const limitsHead = document.querySelector(".limits-head");

      const motorTargets = new Map();
      let defaultTarget = { units: "revs", value: 0 };
      let defaultTargetValues = { revs: 0, degrees: 0, steps: 0 };
      let editingTarget = false;
      let defaultLimitRange = { min: 0, max: 0 };
      let lastLimitSequence = 0;
      let maxSpeedLimitNote = null;

      const numberOrNull = (value) =>
        typeof value === "number" && !Number.isNaN(value) ? value : null;
      const formatInt = (value) => {
        const num = numberOrNull(value);
        return num === null ? "—" : Math.round(num).toString();
      };
      const setInputValue = (input, value) => {
        if (document.activeElement === input) return;
        if (value === undefined || value === null || value === "") {
          input.value = "";
        } else {
          input.value = value;
        }
      };
      const setHint = (node, text, isError = false) => {
        node.textContent = text || "";
        node.classList.toggle("error", !!isError);
      };

      const unitMeta = {
        revs: { step: 0.01, min: 0 },
        degrees: { step: 0.1, min: 0 },
        steps: { step: 1, min: 1 },
      };

      const normalizeUnits = (value) => {
        if (value === "steps") return "steps";
        if (value === "degrees") return "degrees";
        return "revs";
      };

      const applyUnitMeta = (input, units) => {
        const meta = unitMeta[units] || unitMeta.revs;
        input.step = meta.step;
        input.min = meta.min;
        input.placeholder = units;
      };

      const formatTargetDisplay = (units, value) => {
        const num = numberOrNull(value);
        if (num === null) return "";
        if (units === "steps") return Math.round(num).toString();
        if (units === "degrees") return num.toFixed(1);
        return num.toFixed(3);
      };

      const clampTargetValue = (units, rawValue) => {
        const meta = unitMeta[units] || unitMeta.revs;
        const parsed = Number.parseFloat(rawValue);
        if (!Number.isFinite(parsed)) {
          return null;
        }
        const value = Math.max(meta.min, parsed);
        if (units === "steps") {
          return Math.round(value);
        }
        if (units === "degrees") {
          return Math.round(value * 10) / 10;
        }
        return value;
      };

      const convertTargetValue = (value, fromUnits, toUnits, stepsPerRev) => {
        if (!Number.isFinite(value) || fromUnits === toUnits) {
          return value;
        }
        const spr = Number.isFinite(stepsPerRev) && stepsPerRev > 0 ? stepsPerRev : null;
        if (!spr) {
          return value;
        }
        let stepsValue = value;
        if (fromUnits === "degrees") {
          stepsValue = (value / 360) * spr;
        } else if (fromUnits === "revs") {
          stepsValue = value * spr;
        }
        if (toUnits === "steps") {
          return stepsValue;
        }
        if (toUnits === "degrees") {
          return (stepsValue * 360) / spr;
        }
        return stepsValue / spr;
      };

      const computeDefaultLimitRange = (stepsPerRev) => {
        if (!Number.isFinite(stepsPerRev) || stepsPerRev <= 0) {
          return { min: 0, max: 0 };
        }
        const spr = Math.round(stepsPerRev);
        const half = Math.round(spr / 2);
        return { min: -half, max: half };
      };

      const updateLimitInputsState = (enabled) => {
        limitSettings.classList.toggle("hidden", !enabled);
        limitMinInput.disabled = !enabled;
        limitMaxInput.disabled = !enabled;
      };

      const readLimitInputs = () => {
        const limitMin = Number.parseInt(limitMinInput.value, 10);
        const limitMax = Number.parseInt(limitMaxInput.value, 10);
        if (!Number.isFinite(limitMin) || !Number.isFinite(limitMax)) {
          setHint(formHint, "Enter valid limit min/max", true);
          return null;
        }
        if (limitMin > limitMax) {
          setHint(formHint, "Limit min must be ≤ max", true);
          return null;
        }
        return { limitMin, limitMax };
      };

      const getEffectiveLimits = () => {
        const settings = currentState?.settings || {};
        const stepsPerRev = numberOrNull(settings.stepsPerRev);
        const fallback = computeDefaultLimitRange(stepsPerRev);
        const min = Number(settings.limitMin);
        const max = Number(settings.limitMax);
        return {
          min: Number.isFinite(min) ? Math.round(min) : fallback.min,
          max: Number.isFinite(max) ? Math.round(max) : fallback.max,
        };
      };

      const runToAbsolutePosition = async (motorId, targetPosition, label) => {
        const motor = (currentState?.motors || []).find((m) => m.id === motorId);
        if (!motor) {
          throw new Error("Motor not found");
        }

        const currentPosition = Number(motor.currentPosition) || 0;
        let delta = Math.round(targetPosition - currentPosition);
        if (delta === 0) {
          setHint(runHint, `Motor ${motorId}: already at ${label}`);
          return;
        }

        const direction = delta >= 0 ? 1 : -1;
        if (delta < 0) {
          delta = -delta;
        }

        try {
          const settingsData = await sendSettings({ targetUnits: "steps", targetSteps: delta });
          renderState(settingsData);
          setHint(runHint, `Motor ${motorId}: starting ${label}…`);
          const runData = await sendRun(motorId, "single", direction);
          renderState(runData);
          setHint(runHint, `Motor ${motorId}: running ${label}`);
        } catch (err) {
          setHint(runHint, err.message || `Failed to move to ${label}`, true);
          throw err;
        }
      };


      const lastRunStartSeen = new Map();
      let currentState = null;
      let pollTimer = null;
      let settingsSaveToken = 0;

      const renderSettings = (settings) => {
        const stepsPerRev = numberOrNull(settings.stepsPerRev);
        const targetSteps = numberOrNull(settings.targetSteps);
        const targetRevs = numberOrNull(settings.targetRevs);
        const targetDegrees = numberOrNull(settings.targetDegrees);

        let stepsValue = targetSteps;
        if (stepsValue === null && targetRevs !== null && stepsPerRev) {
          stepsValue = Math.round(targetRevs * stepsPerRev);
        } else if (stepsValue === null && targetDegrees !== null && stepsPerRev) {
          stepsValue = Math.round((targetDegrees / 360) * stepsPerRev);
        }

        let revsValue = targetRevs;
        if (revsValue === null && stepsValue !== null && stepsPerRev) {
          revsValue = stepsValue / stepsPerRev;
        } else if (revsValue === null && targetDegrees !== null) {
          revsValue = targetDegrees / 360;
        }

        let degreesValue = targetDegrees;
        if (degreesValue === null && stepsValue !== null && stepsPerRev) {
          degreesValue = (stepsValue * 360) / stepsPerRev;
        } else if (degreesValue === null && revsValue !== null) {
          degreesValue = revsValue * 360;
        }

        defaultTargetValues = {
          steps: stepsValue ?? 0,
          revs: revsValue ?? 0,
          degrees: degreesValue ?? 0,
        };

        const targetUnits = normalizeUnits(settings.targetUnits);
        defaultTarget = {
          units: targetUnits,
          value: defaultTargetValues[targetUnits] ?? 0,
        };

        const limitsEnabled = settings.limitsEnabled === true;
        const limitMinValue = numberOrNull(settings.limitMin);
        const limitMaxValue = numberOrNull(settings.limitMax);
        defaultLimitRange = computeDefaultLimitRange(stepsPerRev);
        limitsToggle.checked = limitsEnabled;
        setInputValue(
          limitMinInput,
          limitMinValue !== null ? limitMinValue : defaultLimitRange.min
        );
        setInputValue(
          limitMaxInput,
          limitMaxValue !== null ? limitMaxValue : defaultLimitRange.max
        );
        updateLimitInputsState(limitsEnabled);

        motorTargets.forEach((entry, key) => {
          if (entry && entry.dirty) {
            return;
          }
          const units = entry ? normalizeUnits(entry.units) : targetUnits;
          const display = formatTargetDisplay(
            units,
            defaultTargetValues[units] ?? 0
          );
          motorTargets.set(key, {
            units,
            value: display,
            dirty: false,
          });
        });

        setInputValue(stepsInput, settings.stepsPerRev ?? "");
        setInputValue(
          maxSpeedInput,
          settings.maxSpeed !== undefined ? Math.round(settings.maxSpeed) : ""
        );
        setInputValue(
          accelInput,
          settings.acceleration !== undefined
            ? Math.round(settings.acceleration)
            : ""
        );
        autoSleepToggle.checked = settings.autoSleep !== false;

        if (!maxSpeedLimitNote) {
          maxSpeedLimitNote = document.createElement("span");
          maxSpeedLimitNote.id = "max-speed-limit-note";
          maxSpeedLimitNote.className = "field-note";
          maxSpeedInput.parentElement.append(maxSpeedLimitNote);
        }

        if (settings.maxSpeedLimit) {
          const limit = Math.round(settings.maxSpeedLimit);
          maxSpeedInput.max = limit;
          maxSpeedInput.title = `Limit ${limit} steps/s`;
          maxSpeedLimitNote.textContent = `Limit ${limit} steps/s`;
        } else {
          maxSpeedInput.removeAttribute("max");
          maxSpeedInput.removeAttribute("title");
          maxSpeedLimitNote.textContent = "";
        }
      };

      const createDot = (on) => {
        const dot = document.createElement("span");
        dot.className = `dot ${on ? "ok" : "bad"}`;
        return dot;
      };

      const createActionButton = (
        label,
        action,
        motorId,
        disabled = false,
        classes = []
      ) => {
        const button = document.createElement("button");
        button.type = "button";
        button.dataset.action = action;
        button.dataset.motorId = String(motorId);
        button.textContent = label;
        button.disabled = disabled;
        ["compact", ...classes].forEach((cls) => button.classList.add(cls));
        return button;
      };

      const createStatusChip = (on, label) => {
        const chip = document.createElement("span");
        chip.className = "status-chip";
        chip.append(createDot(on), document.createTextNode(label));
        return chip;
      };

      const renderMotorsTable = (motors, settings) => {
        if (editingTarget) {
          return;
        }
        const activeElement = document.activeElement;
        const isTargetInput =
          activeElement && activeElement.classList.contains("motor-target-input");
        const isTargetSelect =
          activeElement && activeElement.classList.contains("motor-target-units");
        const activeTarget = isTargetInput || isTargetSelect
          ? {
              motorId: activeElement.dataset.motorId || null,
              type: isTargetInput ? "input" : "select",
              selectionStart: isTargetInput ? activeElement.selectionStart : null,
              selectionEnd: isTargetInput ? activeElement.selectionEnd : null,
            }
          : null;

        const fragment = document.createDocumentFragment();
        const autoSleepEnabled = settings.autoSleep !== false;
        const limitsEnabled = settings.limitsEnabled === true;
        if (limitsHead) {
          limitsHead.classList.toggle("hidden", !limitsEnabled);
        }
        const seen = new Set();
        let lastRunMessage = null;

        if (!motors.length) {
          const colspan = limitsEnabled ? 5 : 4;
          motorsTableBody.innerHTML =
            `<tr class="empty"><td colspan="${colspan}">No motors configured. Use Edit motors to add one.</td></tr>`;
          lastRunStartSeen.clear();
          motorTargets.clear();
          if (!runHint.textContent) {
            setHint(runHint, "No motors configured. Use Edit motors to add one.");
          }
          return;
        }

        motors.forEach((motor) => {
          const motorId = String(motor.id);
          seen.add(motorId);
          const tr = document.createElement("tr");
          tr.dataset.motorId = motorId;

          const modeRaw = (motor.mode || "idle").toString().toLowerCase();
          const moving = !!motor.moving;
          const driverAwake = motor.driverAwake !== false;
          const canRun = modeRaw === "idle" && (autoSleepEnabled || driverAwake);
          const canStop = modeRaw !== "idle" || moving;

          const motorCell = document.createElement("td");
          motorCell.className = "motor-cell";
          const pinsLabel = `Pins – step: ${motor.pins.step} dir: ${motor.pins.dir} sleep: ${motor.pins.sleep}`;
          const motorName = document.createElement("div");
          motorName.className = "motor-name";
          motorName.textContent = `Motor ${motor.id}`;
          const motorPins = document.createElement("span");
          motorPins.className = "motor-pin-icon";
          motorPins.dataset.tooltip = pinsLabel;
          motorPins.setAttribute("aria-label", `Pins for motor ${motor.id}`);
          motorPins.textContent = "ⓘ";
          const motorHeader = document.createElement("div");
          motorHeader.className = "motor-header";
          motorHeader.append(motorName, motorPins);
          motorCell.append(motorHeader);

          const statusGrid = document.createElement("div");
          statusGrid.className = "motor-status-grid";

          const idleColumn = document.createElement("div");
          idleColumn.className = "status-column";
          idleColumn.append(createStatusChip(moving, moving ? "Running" : "Idle"));
          idleColumn.append(
            createActionButton("Stop", "stop", motor.id, !canStop, ["stop-button"])
          );

          const sleepColumn = document.createElement("div");
          sleepColumn.className = "status-column";
          sleepColumn.append(
            createStatusChip(driverAwake, driverAwake ? "Driver awake" : "Sleeping")
          );
          sleepColumn.append(
            createActionButton(
              driverAwake ? "Sleep" : "Wake",
              "toggle-driver",
              motor.id,
              false,
              ["secondary"]
            )
          );

          statusGrid.append(idleColumn, sleepColumn);
          motorCell.append(statusGrid);
          tr.append(motorCell);

          const positionCell = document.createElement("td");
          positionCell.className = "motor-position";
          const positionValue = document.createElement("span");
          positionValue.className = "motor-position-value";
          positionValue.textContent = formatInt(motor.currentPosition);
          positionCell.append(positionValue);
          tr.append(positionCell);

          const targetCell = document.createElement("td");
          targetCell.className = "motor-target-cell";
          const targetWrap = document.createElement("div");
          targetWrap.className = "motor-target";
          const storedTarget = motorTargets.get(motor.id);
          const targetUnits = normalizeUnits(
            storedTarget?.units || defaultTarget.units
          );
          const fallbackDisplay = formatTargetDisplay(
            targetUnits,
            defaultTargetValues[targetUnits] ?? 0
          );
          const initialDirty = storedTarget?.dirty ?? false;
          const initialValue = initialDirty
            ? storedTarget?.value ?? ""
            : fallbackDisplay;
          const targetInput = document.createElement("input");
          targetInput.type = "number";
          targetInput.className = "motor-target-input";
          targetInput.dataset.motorId = motorId;
          applyUnitMeta(targetInput, targetUnits);
          setInputValue(targetInput, initialValue);

          const unitsSelect = document.createElement("select");
          unitsSelect.className = "motor-target-units";
          unitsSelect.dataset.motorId = motorId;
          [
            { value: "revs", label: "Revs" },
            { value: "degrees", label: "Degrees" },
            { value: "steps", label: "Steps" },
          ].forEach(({ value, label }) => {
            const option = document.createElement("option");
            option.value = value;
            option.textContent = label;
            unitsSelect.append(option);
          });
          unitsSelect.value = targetUnits;

          const persistTarget = (units, value, dirty) => {
            motorTargets.set(motor.id, {
              units,
              value,
              dirty,
            });
          };

          persistTarget(targetUnits, targetInput.value, initialDirty);

          targetInput.addEventListener("focus", () => {
            editingTarget = true;
          });
          targetInput.addEventListener("blur", () => {
            editingTarget = false;
          });
          targetInput.addEventListener("input", () => {
            persistTarget(unitsSelect.value, targetInput.value, true);
          });
          targetInput.addEventListener("change", () => {
            const units = normalizeUnits(unitsSelect.value);
            const normalized = clampTargetValue(units, targetInput.value);
            if (normalized === null) {
              persistTarget(units, targetInput.value, true);
              return;
            }
            const display = formatTargetDisplay(units, normalized);
            setInputValue(targetInput, display);
            persistTarget(units, display, true);
          });

          unitsSelect.addEventListener("focus", () => {
            editingTarget = true;
          });
          unitsSelect.addEventListener("blur", () => {
            editingTarget = false;
          });
          unitsSelect.addEventListener("change", () => {
            const units = normalizeUnits(unitsSelect.value);
            const entry = motorTargets.get(motor.id);
            const previousUnits = normalizeUnits(entry?.units || targetUnits);
            const stepsPerRev = numberOrNull(settings.stepsPerRev);
            const currentValue = clampTargetValue(previousUnits, targetInput.value);
            const converted =
              currentValue === null
                ? null
                : convertTargetValue(currentValue, previousUnits, units, stepsPerRev);
            applyUnitMeta(targetInput, units);
            const display =
              converted === null ? "" : formatTargetDisplay(units, converted);
            targetInput.value = display;
            persistTarget(units, display, true);
          });

          const targetRow = document.createElement("div");
          targetRow.className = "target-row";
          targetRow.append(targetInput, unitsSelect);

          const runRow = document.createElement("div");
          runRow.className = "target-run-row";
          runRow.append(
            createActionButton("Reverse", "run-reverse", motor.id, !canRun),
            createActionButton("Forward", "run-forward", motor.id, !canRun)
          );

          const pingRow = document.createElement("div");
          pingRow.className = "target-ping-row";
          pingRow.append(
            createActionButton("Ping-Pong", "run-pingpong", motor.id, !canRun, ["secondary"])
          );

          targetWrap.append(targetRow, runRow, pingRow);
          targetCell.append(targetWrap);
          tr.append(targetCell);

          const resetButton = createActionButton("Reset", "reset", motor.id, false, ["secondary", "reset-button"]);
          positionCell.append(resetButton);

          if (limitsEnabled) {
            const limitsCell = document.createElement("td");
            limitsCell.className = "limits-cell";
            const limitsRow = document.createElement("div");
            limitsRow.className = "limits-actions";
            const limitsTop = document.createElement("div");
            limitsTop.className = "limits-top-row";
            limitsTop.append(
              createActionButton("Min", "run-min", motor.id, !canRun),
              createActionButton("Max", "run-max", motor.id, !canRun)
            );
            const midRow = document.createElement("div");
            midRow.className = "limits-mid-row";
            midRow.append(createActionButton("Mid", "run-mid", motor.id, !canRun));
            limitsRow.append(limitsTop, midRow);
            limitsCell.append(limitsRow);
            tr.append(limitsCell);
          }

          const lastRun = motor.lastRun || {};
          if (lastRun.valid && typeof lastRun.startMs === "number") {
            const key = motorId;
            if (lastRunStartSeen.get(key) !== lastRun.startMs) {
              const durationSec = (Number(lastRun.durationMs) || 0) / 1000;
              const stepsDone = Math.abs(Number(lastRun.steps) || 0);
              const gapUs = Number(lastRun.loopMaxGapUs) || 0;
              const gapText = gapUs > 0 ? ` gap ${(gapUs / 1000).toFixed(3)}ms` : "";
              const prefix = lastRun.aborted ? "Aborted" : "Finished";
              lastRunMessage = `Motor ${motor.id}: ${prefix} · steps ${Math.round(stepsDone)} · time ${durationSec.toFixed(2)}s${gapText}`;
              lastRunStartSeen.set(key, lastRun.startMs);
            }
          }

          fragment.append(tr);
        });

        motorsTableBody.replaceChildren(fragment);

        if (activeTarget && activeTarget.motorId) {
          const selector =
            activeTarget.type === "select"
              ? `select.motor-target-units[data-motor-id="${activeTarget.motorId}"]`
              : `input.motor-target-input[data-motor-id="${activeTarget.motorId}"]`;
          const nextEl = motorsTableBody.querySelector(selector);
          if (nextEl) {
            nextEl.focus();
            if (
              activeTarget.type === "input" &&
              activeTarget.selectionStart !== null &&
              activeTarget.selectionEnd !== null &&
              nextEl.setSelectionRange
            ) {
              try {
                nextEl.setSelectionRange(
                  activeTarget.selectionStart,
                  activeTarget.selectionEnd
                );
              } catch (err) {
                /* ignore */
              }
            }
          }
        }

        Array.from(lastRunStartSeen.keys()).forEach((key) => {
          if (!seen.has(key)) {
            lastRunStartSeen.delete(key);
          }
        });
        Array.from(motorTargets.keys()).forEach((key) => {
          if (!seen.has(String(key))) {
            motorTargets.delete(key);
          }
        });

        if (lastRunMessage) {
          setHint(runHint, lastRunMessage);
        }
      };

      const renderMotorEditor = (motors) => {
        if (motorEditor.classList.contains("hidden")) {
          return;
        }

        if (!motors.length) {
          motorEditList.innerHTML =
            '<p class="hint">No motors yet. Add a new motor below.</p>';
          return;
        }

        motorEditList.innerHTML = motors
          .map((motor) => {
            const step = Number(motor.pins.step ?? "");
            const dir = Number(motor.pins.dir ?? "");
            const sleep = Number(motor.pins.sleep ?? "");
            return `
              <div class="motor-edit" data-motor="${motor.id}">
                <h4>Motor ${motor.id}</h4>
                <div class="motor-edit-grid">
                  <label>
                    Step pin
                    <input type="number" min="0" step="1" data-field="step" value="${step}" />
                  </label>
                  <label>
                    Dir pin
                    <input type="number" min="0" step="1" data-field="dir" value="${dir}" />
                  </label>
                  <label>
                    Sleep pin
                    <input type="number" min="0" step="1" data-field="sleep" value="${sleep}" />
                  </label>
                </div>
                <div class="form-actions">
                  <button type="button" class="compact" data-action="save" data-motor-id="${motor.id}">Update</button>
                  <button type="button" class="secondary danger compact" data-action="remove" data-motor-id="${motor.id}">Remove</button>
                </div>
              </div>
            `;
          })
          .join("");
      };

      const renderState = (data) => {
        currentState = data;
        const settings = data?.settings || {};
        const motors = Array.isArray(data?.motors) ? data.motors : [];

        renderSettings(settings);
        renderMotorsTable(motors, settings);
        if (!motorEditor.classList.contains("hidden")) {
          renderMotorEditor(motors);
        }

        const limitStatus = data?.limitStatus || {};
        const sequence = Number(limitStatus.sequence) || 0;
        if (sequence && sequence !== lastLimitSequence) {
          lastLimitSequence = sequence;
          const motorId = Number(limitStatus.motorId) || 0;
          const suffix = motorId > 0 ? ` (motor ${motorId})` : "";
          setHint(runHint, `Motion limit triggered${suffix}`);
        }

        updatedEl.textContent = `Updated ${new Date().toLocaleTimeString()}`;
      };

      const fetchState = async (showErrors = false) => {
        try {
          const res = await fetch("/api/state", { cache: "no-store" });
          if (!res.ok) throw new Error(res.status);
          const data = await res.json();
          renderState(data);
          if (showErrors) setHint(formHint, "");
        } catch (err) {
          if (showErrors) {
            setHint(formHint, "Could not load state", true);
          }
        }
      };

      const sendSettings = async (payload) => {
        const res = await fetch("/api/settings", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const collectSettingsFromInputs = () => {
        const stepsPerRev = Number.parseInt(stepsInput.value, 10);
        const maxSpeed = Number.parseFloat(maxSpeedInput.value);
        const acceleration = Number.parseFloat(accelInput.value);

        if (!Number.isFinite(stepsPerRev) || stepsPerRev < 1) {
          setHint(formHint, "Steps per rev must be at least 1", true);
          return null;
        }
        if (!Number.isFinite(maxSpeed) || maxSpeed < 1) {
          setHint(formHint, "Set a valid max speed", true);
          return null;
        }
        if (!Number.isFinite(acceleration) || acceleration < 1) {
          setHint(formHint, "Set a valid acceleration", true);
          return null;
        }

        return {
          stepsPerRev,
          maxSpeed,
          acceleration,
        };
      };

      const saveSettingsFromInputs = async () => {
        const payload = collectSettingsFromInputs();
        if (!payload) {
          return;
        }

        const requestId = ++settingsSaveToken;
        setHint(formHint, "");

        try {
          const data = await sendSettings(payload);
          if (requestId === settingsSaveToken) {
            renderState(data);
          }
        } catch (err) {
          if (requestId === settingsSaveToken) {
            setHint(formHint, err.message || "Failed to save", true);
          }
        }
      };

      [stepsInput, maxSpeedInput, accelInput].forEach((input) => {
        input.addEventListener("change", () => {
          void saveSettingsFromInputs();
        });
      });

      const sendLimitSettings = async (payload) => {
        try {
          setHint(formHint, "");
          const data = await sendSettings(payload);
          renderState(data);
        } catch (err) {
          setHint(formHint, err.message || "Failed to update limits", true);
          throw err;
        }
      };

      limitsToggle.addEventListener("change", async () => {
        const enabled = limitsToggle.checked;
        if (enabled) {
          if (limitMinInput.value === "" && limitMaxInput.value === "") {
            limitMinInput.value = defaultLimitRange.min;
            limitMaxInput.value = defaultLimitRange.max;
          } else {
            if (limitMinInput.value === "") {
              limitMinInput.value = defaultLimitRange.min;
            }
            if (limitMaxInput.value === "") {
              limitMaxInput.value = defaultLimitRange.max;
            }
          }
        }

        updateLimitInputsState(enabled);

        if (enabled) {
          const values = readLimitInputs();
          if (!values) {
            limitsToggle.checked = false;
            updateLimitInputsState(false);
            return;
          }
          try {
            await sendLimitSettings({ limitsEnabled: true, ...values });
            setHint(runHint, "Motion limits enabled");
          } catch (err) {
            limitsToggle.checked = false;
            updateLimitInputsState(false);
          }
        } else {
          try {
            await sendLimitSettings({ limitsEnabled: false });
            setHint(runHint, "Motion limits disabled");
          } catch (err) {
            limitsToggle.checked = true;
            updateLimitInputsState(true);
          }
        }
      });

      [limitMinInput, limitMaxInput].forEach((input) => {
        input.addEventListener("change", async () => {
          if (!limitsToggle.checked) {
            return;
          }
          const values = readLimitInputs();
          if (!values) {
            return;
          }
          try {
            await sendLimitSettings(values);
          } catch (err) {
            const fallback = currentState?.settings || {};
            limitMinInput.value =
              fallback.limitMin ?? defaultLimitRange.min;
            limitMaxInput.value =
              fallback.limitMax ?? defaultLimitRange.max;
          }
        });
      });

      const sendRun = async (motorId, mode, direction) => {
        const res = await fetch("/api/run", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ motorId, mode, direction }),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const sendStop = async (motorId) => {
        const res = await fetch("/api/stop", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ motorId }),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const sendReset = async (motorId) => {
        const res = await fetch("/api/reset", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ motorId }),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const sendDriver = async (motorId, awake) => {
        const res = await fetch("/api/driver", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ motorId, awake }),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const sendRestoreDefaults = async () => {
        const res = await fetch("/api/settings/default/restore", { method: "POST" });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const sendSaveDefaults = async () => {
        const res = await fetch("/api/settings/default/save", { method: "POST" });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const sendMotorAdd = async (pins) => {
        const res = await fetch("/api/motors/add", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(pins),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const sendMotorUpdate = async (motorId, pins) => {
        const res = await fetch("/api/motors/update", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ motorId, ...pins }),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const sendMotorRemove = async (motorId) => {
        const res = await fetch("/api/motors/remove", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ motorId }),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || res.statusText);
        }
        return res.json();
      };

      const targetApproximatelyEqual = (units, a, b) => {
        if (!Number.isFinite(a) || !Number.isFinite(b)) {
          return false;
        }
        if (units === "steps") {
          return Math.round(a) === Math.round(b);
        }
        if (units === "degrees") {
          return Math.abs(a - b) <= 0.05;
        }
        return Math.abs(a - b) <= 0.0005;
      };

      const ensureTargetForMotor = async (motorId) => {
        const entry = motorTargets.get(motorId);
        const units = normalizeUnits(entry?.units || defaultTarget.units);
        const fallbackDisplay = formatTargetDisplay(
          units,
          defaultTargetValues[units] ?? 0
        );
        const rawValue =
          entry && entry.value !== undefined && entry.value !== null && entry.value !== ""
            ? entry.value
            : fallbackDisplay;
        const normalized = clampTargetValue(units, rawValue);
        if (normalized === null) {
          throw new Error("Enter a valid target before running");
        }

        const currentUnits = normalizeUnits(currentState?.settings?.targetUnits);
        const currentValue = defaultTargetValues[units];
        if (
          currentUnits === units &&
          currentValue !== undefined &&
          targetApproximatelyEqual(units, currentValue, normalized)
        ) {
          return currentState;
        }

        const payload = { targetUnits: units, targetValue: normalized };
        const data = await sendSettings(payload);
        const display = formatTargetDisplay(units, normalized);
        motorTargets.set(motorId, { units, value: display, dirty: true });
        renderState(data);
        return data;
      };

      motorsTableBody.addEventListener("click", async (event) => {
        const button = event.target.closest("button[data-action]");
        if (!button) return;
        const motorId = Number.parseInt(button.dataset.motorId || "", 10);
        if (!Number.isInteger(motorId)) return;
        const action = button.dataset.action;

        try {
          if (action === "run-forward") {
            await ensureTargetForMotor(motorId);
            setHint(runHint, `Motor ${motorId}: starting forward…`);
            const data = await sendRun(motorId, "single", 1);
            renderState(data);
            setHint(runHint, `Motor ${motorId}: running forward`);
          } else if (action === "run-reverse") {
            await ensureTargetForMotor(motorId);
            setHint(runHint, `Motor ${motorId}: starting reverse…`);
            const data = await sendRun(motorId, "single", -1);
            renderState(data);
            setHint(runHint, `Motor ${motorId}: running reverse`);
          } else if (action === "run-max" || action === "run-mid" || action === "run-min") {
            if (!currentState?.settings?.limitsEnabled) {
              setHint(runHint, "Enable motion limits to use preset moves", true);
              return;
            }
            const limits = getEffectiveLimits();
            let label;
            let targetPosition;
            if (action === "run-max") {
              label = "max";
              targetPosition = limits.max;
            } else if (action === "run-min") {
              label = "min";
              targetPosition = limits.min;
            } else {
              label = "mid";
              targetPosition = Math.round((limits.min + limits.max) / 2);
            }
            await runToAbsolutePosition(motorId, targetPosition, label);
          } else if (action === "run-pingpong") {
            await ensureTargetForMotor(motorId);
            setHint(runHint, `Motor ${motorId}: starting ping-pong…`);
            const data = await sendRun(motorId, "pingpong", 1);
            renderState(data);
            setHint(runHint, `Motor ${motorId}: ping-pong running`);
          } else if (action === "stop") {
            setHint(runHint, `Motor ${motorId}: stopping…`);
            const data = await sendStop(motorId);
            renderState(data);
            setHint(runHint, `Motor ${motorId}: stop requested`);
          } else if (action === "reset") {
            setHint(runHint, `Motor ${motorId}: resetting…`);
            const data = await sendReset(motorId);
            renderState(data);
            setHint(runHint, `Motor ${motorId}: position reset`);
          } else if (action === "toggle-driver") {
            const motor = (currentState?.motors || []).find((m) => m.id === motorId);
            const driverAwake = motor ? motor.driverAwake !== false : false;
            setHint(runHint, `Motor ${motorId}: ${driverAwake ? "sleeping" : "waking"} driver…`);
            const data = await sendDriver(motorId, !driverAwake);
            renderState(data);
            setHint(runHint, `Motor ${motorId}: driver ${driverAwake ? "sleep" : "awake"}`);
          }
        } catch (err) {
          setHint(runHint, err.message || "Command failed", true);
        }
      });

      toggleMotorEditorBtn.addEventListener("click", () => {
        const willShow = motorEditor.classList.contains("hidden");
        motorEditor.classList.toggle("hidden");
        toggleMotorEditorBtn.textContent = willShow ? "Hide editor" : "Edit motors";
        if (willShow) {
          renderMotorEditor(currentState?.motors || []);
          setHint(motorEditorHint, "");
        }
      });

      const parsePinInput = (input) => {
        const value = Number.parseInt(input.value, 10);
        return Number.isFinite(value) ? value : null;
      };

      motorEditorAddBtn.addEventListener("click", async () => {
        const step = parsePinInput(motorEditorStep);
        const dir = parsePinInput(motorEditorDir);
        const sleep = parsePinInput(motorEditorSleep);
        if (!Number.isInteger(step) || !Number.isInteger(dir) || !Number.isInteger(sleep)) {
          setHint(motorEditorHint, "Enter valid pins for new motor", true);
          return;
        }
        try {
          setHint(motorEditorHint, "Adding motor…");
          const data = await sendMotorAdd({ step, dir, sleep });
          renderState(data);
          motorEditorStep.value = "";
          motorEditorDir.value = "";
          motorEditorSleep.value = "";
          setHint(motorEditorHint, "Motor added");
        } catch (err) {
          setHint(motorEditorHint, err.message || "Failed to add motor", true);
        }
      });

      motorEditList.addEventListener("click", async (event) => {
        const button = event.target.closest("button[data-action]");
        if (!button) return;
        const motorId = Number.parseInt(button.dataset.motorId || "", 10);
        if (!Number.isInteger(motorId)) return;
        const container = button.closest(".motor-edit");
        if (!container) return;

        const readPins = () => {
          const step = Number.parseInt(
            container.querySelector("input[data-field='step']").value,
            10
          );
          const dir = Number.parseInt(
            container.querySelector("input[data-field='dir']").value,
            10
          );
          const sleep = Number.parseInt(
            container.querySelector("input[data-field='sleep']").value,
            10
          );
          return { step, dir, sleep };
        };

        try {
          if (button.dataset.action === "save") {
            const pins = readPins();
            if (
              !Number.isInteger(pins.step) ||
              !Number.isInteger(pins.dir) ||
              !Number.isInteger(pins.sleep)
            ) {
              setHint(motorEditorHint, "Enter valid pins", true);
              return;
            }
            setHint(motorEditorHint, `Updating motor ${motorId}…`);
            const data = await sendMotorUpdate(motorId, pins);
            renderState(data);
            setHint(motorEditorHint, `Motor ${motorId} updated`);
          } else if (button.dataset.action === "remove") {
            if (!window.confirm(`Remove motor ${motorId}?`)) {
              return;
            }
            setHint(motorEditorHint, `Removing motor ${motorId}…`);
            const data = await sendMotorRemove(motorId);
            renderState(data);
            setHint(motorEditorHint, `Motor ${motorId} removed`);
          }
        } catch (err) {
          setHint(motorEditorHint, err.message || "Motor update failed", true);
        }
      });

      resetDefaultsButton.addEventListener("click", async () => {
        settingsSaveToken += 1;
        try {
          setHint(formHint, "Restoring defaults…");
          const data = await sendRestoreDefaults();
          renderState(data);
          setHint(formHint, "Defaults restored");
        } catch (err) {
          setHint(formHint, err.message || "Failed to restore defaults", true);
        }
      });

      saveDefaultsButton.addEventListener("click", async () => {
        if (!window.confirm("Save current motion settings to ESP32 as default?")) {
          return;
        }
        settingsSaveToken += 1;
        try {
          setHint(formHint, "Saving defaults…");
          const data = await sendSaveDefaults();
          renderState(data);
          setHint(formHint, "Defaults saved");
        } catch (err) {
          setHint(formHint, err.message || "Failed to save defaults", true);
        }
      });

      autoSleepToggle.addEventListener("change", async () => {
        const enabled = autoSleepToggle.checked;
        try {
          setHint(runHint, enabled ? "Auto sleep enabled" : "Auto sleep disabled");
          const data = await sendSettings({ autoSleep: enabled });
          renderState(data);
        } catch (err) {
          setHint(runHint, err.message || "Failed to update auto sleep", true);
        }
      });

      const startPolling = () => {
        if (pollTimer) clearInterval(pollTimer);
        pollTimer = setInterval(fetchState, 1500);
      };

      fetchState(true).then(startPolling);
    </script>

  </body>
</html>
